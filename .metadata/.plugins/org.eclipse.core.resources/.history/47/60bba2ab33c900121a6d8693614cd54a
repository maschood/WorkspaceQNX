/*
 * RS232_1.cpp
 *
 *  Created on: 16.04.2013
 *      Author: maschood
 */

#include "RS232_1.h"

RS232_1* RS232_1::instance = NULL;
Mutex* RS232_1::RS232InstanceMutex = new Mutex();

RS232_1::RS232_1()
{
	recvbuf = -1;
	struct termios ts;

	if((fd = open(DEV_SER1, O_RDWR | O_NOCTTY)) < 0)
	{
		printf("Debug RS232_1: opening devfile1 failed\n");
		exit(EXIT_FAILURE);
	} else {
#ifdef DEBUG_RS232
		printf("Debug RS232_1: opening devfile1 SUCCESSED\n");
#endif
	}

	// flushes data received but not read and
	// data written but not transmitted
	tcflush(fd, TCIOFLUSH);

	sleep(1);

	// Einstellung der Schnittstelle holen
	tcgetattr(fd, &ts);

	// Input/Output Datenrate setzen
	cfsetispeed(&ts, B19200);
	cfsetospeed(&ts, B19200);

	// Schnittstelle konfigurieren
	ts.c_cflag &= ~CSIZE;	// clear number of data bits
	ts.c_cflag &= ~CSTOPB;	// 2 stop bits
	ts.c_cflag &= ~PARENB;	// no parity bit
	ts.c_cflag |= CS8;		// 8 Data bits
	ts.c_cflag |= CREAD;	// enable receiving characters
	ts.c_cflag |= CLOCAL;	// local connection, no modem contol

	// Einstellungen sofort uebernehmen
	tcsetattr(fd, TCSANOW, &ts);
}



RS232_1::~RS232_1()
{
	delete instance;
	instance = NULL;
	RS232InstanceMutex->~Mutex();
	if(close(fd) < 0){
		printf("error closing (RS232_1) fd\n");
	}
}

RS232_1* RS232_1::getInstance()
{
	if (!instance) {
		RS232InstanceMutex->lock();
		if (!instance) {
			instance = new RS232_1;
#ifdef DEBUG_RS232
			printf("Debug RS232_1: New RS232_1 instance created\n");
#endif
		}
		RS232InstanceMutex->unlock();
	}
	return instance;
}



void RS232_1::execute(void* arg)
{

	buf = buffer;



	for (int i =0; i<len; i++){

		buffer [i]= 666777;
	}

	while(1){


	}





//	int lenRead = 0;
//	while (!isStopped()) {
//		if ((lenRead = readMsg(&recvbuf)) < 0) {
//			printf("recieving from devfile1 failed\n");
//
//		cout<< recvbuf << endl;
//	}
//		switch (recvbuf) {
//		case MSG_TEST:
//			printf("Testmessage recved on devfile1: %c\n", recvbuf);
//			break;
//		case MSG_TIMEOUT:
//#ifdef DEBUG_RS232
//			printf("Debug RS232_1: Timeout recved\n");
//#endif
//			break;
//		default:
//#ifdef DEBUG_RS232
//			printf("Debug RS232_1: Unknown msg recved: %c\n", recvbuf);
//			printf("Message: %h", recvbuf);
//#endif
//			break;
//		}
//
//		recvbuf = 0;
//	}


}



void RS232_1::shutdown()
{
}



int RS232_1::sendMsg(void buf) {
	buf = buffer;
	int rc = write(fd, &buf, 16);

	if (rc < 0) {
		printf("writing on devfile1 failed\n");
		return -1;
	}

	return rc;
}



int RS232_1::readMsg(void* rbuf) {
	int rc = readcond(fd, rbuf, 16, 16, 0, 10);

	if(rc <= 0) {
		if(errno == EAGAIN || rc == 0){
#ifdef DEBUG_RS232
			printf("Debug RS232_1: Timeout or EAGAIN\n");
#endif
			return 0;
		} else {
			printf("recieving from devfile1 failed\n");
			return -1;
		}
	}

	return rc;
}


