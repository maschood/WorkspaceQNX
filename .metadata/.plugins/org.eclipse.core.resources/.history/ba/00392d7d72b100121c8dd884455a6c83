/*
 * HAL_S.cpp
 *
 *  Created on: 23.04.2013
 *      Author: ich
 */

#include "HAL_S/HAL_S.h"

HAL_S* HAL_S::instance = NULL;

HAL_S::HAL_S() {

	// Initialising the IO card
	out8(DIO_BASE + DIO_OFFS_CTRL, 0x8A);
	out8(DIO_BASE + DIO_OFFS_B, 0x00);
	out8(DIO_BASE + DIO_OFFS_C, 0x00);
}

HAL_S::~HAL_S() {
	delete instance;
	instance = NULL;
	out8(DIO_BASE + DIO_OFFS_CTRL, 0x8A);
	out8(DIO_BASE + DIO_OFFS_B, 0x00);
	out8(DIO_BASE + DIO_OFFS_C, 0x00);
}

HAL_S* HAL_S::get_instance() {
	// Requesting access to HW
	if (-1 == ThreadCtl(_NTO_TCTL_IO, 0)) {
		perror("ThreadCtl access failed\n");
		return NULL;
	}

	if (instance == NULL) {
		instance = new HAL_S();
	}

	return instance;
}

void HAL_S::start_process(){

	int last_state;
	int current_state;

	uint8_t *val_b;
	unit8_t *val_c;

	current_state = (&val_b + (&val_c << 8));

	// Hier einen neuen Thread erzeugen
	while(MANOWAR){

		// check if at least one bit is set an a closer check is necessary
		val_b = in8(DIO_BASE + DIO_OFFS_B);
		val_c = in8(DIO_BASE + DIO_OFFS_C);

		last_state = current_state;
		current_state = (val_b + (val_c << 8));

		if(last_state - current_state != 0){
			if((val_b & CHECK_B) != CHECK_B){
				check_entrance(val_b);
				check_hight_determinism(val_b);
				check_bar(val_b);
				check_slide_full(val_b);
				check_exit(val_b);
			}

			if((val_c & 0xf0) != CHECK_C){
				check_start_button(val_c);
				check_stop_button(val_c);
				check_reset_button(val_c);
				check_quick_stop(val_c);
			}
		}
	}
}
